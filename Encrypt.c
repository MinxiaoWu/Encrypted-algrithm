#include <stdio.h>
#include <math.h>
#include <time.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <string.h>
#include "E function.h"
/*-----------------------------------------------------------------------------------------------------*/

int main(void)
{
    char t[300], c[20], a[325], b[20];
    int i=0, j=0, k=0, n=0, z[4], x[10], y[10];

    printf("=======================  Encrypted Model  =======================\n\n");
    printf("The plaintext:\n\n ");
    while ((t[i]=getchar())!='#') /*明文输入*/
    {
        i++;
    } t[i]='\0';
    
    printf("\n\n");
    for ( i = 1; i <=65; i++)
    {
        printf("-");
    }
    printf("\n");

    //------------------------------------------------------------------------------------------//

    /*初次接线加密*/
    
    do                             /*生成接线的字符*/
    {
        for ( i = 0; i < 10; i++)
        {
            *(x+i)=Rand(0,77);
            *(y+i)=Rand(0,77);
        }
    } while (exm(x,10) + exm(y,10) + Double_Exm(x, y, 10) != 3);

    for ( i = 0; i < 10; i++)
    {
        while (*(t+j) != '\0')
        {
            if (pos(*(t+j), 'e') == x[i])
            {
                *(t+j)='<';
            }
            else if (pos(*(t+j), 'e') == y[i])
            {
                *(t+j)='>';
            }
            j++;
        }
        j=0;
        while (*(t+j) != '\0')
        {
            if (*(t+j) == '<')
            {
                *(t+j) = S(y[i], 1);
            }
            else if (*(t+j) == '>')
            {
                *(t+j) = S(x[i], 1);
            }
            j++;
        }
        j=0;
    }

    //------------------------------------------------------------------------------------------//

    /*转子加密*/

    for ( i = 0; i < 4; i++)  /*随机产生转子初值*/
    {
        z[i]=Rand(0,77);
    }
    
    while (*(t+n)!='\0')
    {                        /*初次转子加密*/
        E(z[0]+n, t+n, 1);
        E(z[1]+n/77, t+n, 0);
        E(z[2]+n/pow(77,2), t+n, 0);
        E(z[3]+n/pow(77,3), t+n, 0);

        R(t+n);              /*信号反射*/
                             /*二次转子加密*/
        D(z[3]+n/pow(77,3), t+n, 1);
        D(z[2]+n/pow(77,2), t+n, 1);
        D(z[1]+n/77, t+n, 1);
        D(z[0]+n, t+n, 1);
        n++;
    }

    //------------------------------------------------------------------------------------------//

    /*二次接线加密*/

    j=0;
    for ( i = 0; i < 10; i++)
    {
        while (*(t+j) != '\0')
        {
            if (pos(*(t+j), 'd') == x[i])
            {
                *(t+j)='<';
            }
            else if (pos(*(t+j), 'd') == y[i])
            {
                *(t+j)='>';
            }
            j++;
        }
        j=0;
        while (*(t+j) != '\0')
        {
            if (*(t+j) == '<')
            {
                *(t+j) = S(y[i], 0);
            }
            else if (*(t+j) == '>')
            {
                *(t+j) = S(x[i], 0);
            }
            j++;
        }
        j=0;
    }

    //------------------------------------------------------------------------------------------//

    /*密钥加密，并输出带公钥密文*/

    I_s(x, a, 10);
    I_s(y, b, 10);
    I_s(z, c, 4);

    strcat(a, t);
    strcat(a, c);
    strcat(a, b);

    printf("\n The ciphertext:");
    printf("\n\n  ");
    printf("%s\n\n",a);

    for ( i = 1; i <=65; i++)
    {
        printf("=");
    }
    
    return 0;
}
/*-----------------------------------------------------------------------------------------------------*/